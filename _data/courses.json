[
  {
    "title": "Thiết kế Vi mạch Số từ Cơ bản đến Ứng dụng",
    "comment": "Nắm vững từ Logic đến Bộ xử lý",
    "image": "banner_khoa1.png",
    "duration": "8 phần, 16 buổi",
    "detail": {
      "section": [
        {
          "title": "Phần A: Biểu diễn số & Logic tổ hợp",
          "module": [
            {
              "title": "Buổi 1: Biểu diễn số, Boolean, K-map & Quy trình thiết kế tổ hợp",
              "moduledetail": [
                "Nội dung: Chuyển đổi hệ số (2/8/16↔10, nhị phân phần thập phân, nhị phân↔hex), số có dấu bù-2 (phạm vi, cộng/trừ, phát hiện overflow), cổng logic & đại số Boolean (AND/OR/NOT, DeMorgan, NAND/NOR phổ dụng), dạng biểu diễn SoP/PoS (canonical vs standard), K-map 2-4 biến (nhóm, don't-care, hazard).",
                "Demo: Thiết kế mạch majority(3) từ SoP → K-map → mạch chỉ NAND.",
                "Source: Verilog code majority3.v, testbench tb_majority3.v.",
                "Document: Tutorial Boolean simplification with K-map.",
                "Bài tập: Chuyển đổi số hỗn hợp; cộng bù-2; rút gọn hàm 4 biến có don't-care; SoP/PoS & K-map cho hàm “ít nhất 2 đầu vào = 1”; overflow bù-2."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 2: Mạch tổ hợp chuẩn → Mạch tuần tự cơ bản → Ôn tập tích hợp",
              "moduledetail": [
                "Nội dung: Ghép mạch tổ hợp bằng block chuẩn (Half/Full Adder, MUX/Decoder/Encoder, BCD→7-segment), dùng D-FF để tạo thanh ghi/bộ đếm, tổng hợp FSM đơn giản theo quy trình 5 bước (Moore/Mealy, binary vs one-hot).",
                "Demo: Thiết kế Mod-10 counter có enable & sync-reset; tối giản BCD→7-seg; sequence detector “101” (Moore).",
                "Source: counter10.v, fsm_detector.v, testbenches.",
                "Document: Tutorial Combinational & Sequential Circuits.",
                "Bài tập: ALU 4-bit mini (AND/OR/XOR/ADD/SUB bù-2 + cờ Z/Cout); Mod-12 up/down counter; FSM Mealy ngắn (state-diagram + bảng chuyển)."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần B: Sequential Logic & Datapath cơ bản",
          "module": [
            {
              "title": "Buổi 3: Advanced Sequential Logic & Quy ước FSM/timing",
              "moduledetail": [
                "Nội dung: Clock period/frequency/width/duty-cycle; setup/hold; latch vs FF (SR/D/JK/T, MS vs edge-triggered); phân tích mạch tuần tự (phương trình kích thích, trạng thái kế, timing diagram); FSM tổng hợp, giản đồ chuyển trạng thái, quy ước vẽ; tối thiểu hóa trạng thái (partition, implication table), mã hóa (minimum-bit-change, prioritized adjacency, one-hot); ước lượng cost/delay và chọn FF.",
                "Demo: Bài tập timing tính f & duty từ width/period; vẽ timing FSM nhỏ (Mealy/Moore).",
                "Source: timing_exercise.v, fsm_timing.v.",
                "Document: Tutorial Sequential Logic & FSM Optimization.",
                "Bài tập: Thiết kế counter theo chu trình cho trước bằng D/JK/T và so sánh cost/delay; rà lỗi phổ biến khi vi phạm setup/hold; nộp state table + timing cho một mạch cho trước."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 4: Storage Components (Phần 1): Datapath cơ bản & One's-Counter",
              "moduledetail": [
                "Nội dung: Storage components (registers, counters, RF, queue/stack); datapath 1-ACC & RF 3-port; ALU/Shift ops; control word; ví dụ hệ thống One's-Counter (thuật toán, FSM/ASM, next-state/output, control tín hiệu, datapath & controller).",
                "Demo: Viết control word & mô phỏng One's-Counter trên datapath RF-3port; check tín hiệu Done/Enable.",
                "Source: ones_counter.v, rf3port.v, controller.v.",
                "Document: Tutorial One's-Counter Datapath.",
                "Bài tập: Thiết kế datapath tính tổng S=1+…+n; lên control word và ASM sơ bộ."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần C: Datapath song song & FSMD",
          "module": [
            {
              "title": "Buổi 5: Storage Components (Phần 2): Datapath song song & Control Unit",
              "moduledetail": [
                "Nội dung: Parallel datapath (đồng thời 2 thao tác/cycle, giới hạn đồng thời); custom datapath dùng latches biên để rút ngắn Tclk; các kiểu control-unit (hardwired, ROM, microprogrammed) với trade-offs chi phí/linh hoạt.",
                "Demo: Chuyển thuật toán đơn giản sang datapath-song-song; xác định ràng buộc đồng thời.",
                "Source: parallel_datapath.v, control_unit.v.",
                "Document: Tutorial Parallel Datapath & Control Unit.",
                "Bài tập: Bài tập RF/Stack/Queue/Datapath biến đổi bit theo đề."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 6: Register-Transfer Specification & Design (P1): FSMD, ASM, Ones-Counter RTL",
              "moduledetail": [
                "Nội dung: Mô hình FSMD (tách fC/fD, hC/hD); biến trạng thái datapath, input/output, STAT; đặc tả Ones-Counter ở mức FSMD (state-action/static-action table, ASM symbols & rules); phiên bản state-based và input-based; ánh xạ sang logic RTL cho controller/datapath.",
                "Demo: Viết ASM cho bài S=1..n (BTVN buổi 4), tách control/datapath, xuất tín hiệu điều khiển.",
                "Source: fsmd_ones_counter.v, asm_chart.pdf.",
                "Document: Tutorial FSMD & ASM Chart Design.",
                "Bài tập: Biến thể Ones-Counter (đếm bit 1 theo khối 4-bit), yêu cầu state-table & ASM 2 kiểu."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần D: Tổng hợp ASM & Pipelining",
          "module": [
            {
              "title": "Buổi 7: Register-Transfer (P2): Tổng hợp từ ASM & Chia sẻ tài nguyên",
              "moduledetail": [
                "Nội dung: Pipeline tổng hợp từ ASM; register sharing (non-overlapping lifetime, left-edge algorithm, compatibility graph); functional-unit sharing (operator merging); datapath connectivity & bus sharing; register merging.",
                "Demo: Tạo variable usage table và chạy left-edge bằng tay; vẽ compatibility graph và đề xuất register/ALU/bus groups cho SRA.",
                "Source: asm_to_rtl.v, sra_example.v.",
                "Document: Tutorial ASM Synthesis & Resource Sharing.",
                "Bài tập: Bài ∑a²ᵢ (i=1..100): viết giả mã → ASM → chia sẻ reg/op/bus; nộp datapath tối thiểu."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 8: Register-Transfer (P3): Chaining/Multicycling, Pipelining & Scheduling",
              "moduledetail": [
                "Nội dung: Chaining (nối 2+ thao tác trong cùng state), multicycling (1 thao tác >1 chu kỳ); pipelining (unit, control, datapath, FSMD pipeline, timing); scheduling (ASAP/ALAP, list scheduling, resource-constrained vs time-constrained).",
                "Demo: Lập ASAP/ALAP + list scheduling cho SRA/One's-Counter mở rộng với ràng buộc 2 adders, 1 shifter; so RC vs TC schedule.",
                "Source: scheduling_example.v, asap_alap.pdf.",
                "Document: Tutorial Scheduling & Pipelining.",
                "Bài tập: Đề xuất datapath pipelining 2-3 stage cho One's-Counter và ước lượng thông lượng/độ trễ."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần E: Processor Design",
          "module": [
            {
              "title": "Buổi 9: Processor Design: Từ ISA → CISC/RISC, Pipeline & Hazards",
              "moduledetail": [
                "Nội dung: Instruction Set (kiểu lệnh, số trường địa chỉ, addressing modes); instruction-execution cycle; processor design flow; CISC 16-bit (IS, flowchart, component allocation, ASM, schematic); RISC 32-bit (pipeline 4 stage, forwarding paths, stall/flush, branch prediction).",
                "Demo: Viết assembly cho biểu thức C=(a+b)(a-b) với 1-addr/2-addr/3-addr & so sánh truy cập bộ nhớ; vẽ timing 4-stage cho 2-3 câu lệnh có phụ thuộc, thêm data-forwarding & branch prediction.",
                "Source: mini_cisc.v, mini_risc.v, assembly_examples.s.",
                "Document: Tutorial Processor ISA & Pipeline Design.",
                "Bài tập: Đề cương mini-CPU (subset lệnh, datapath, control unit, pipeline/hazard policy)."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần F: Behavioral Verilog & Testbench",
          "module": [
            {
              "title": "Buổi 10: Behavioral Verilog nâng cao: continuous vs. procedural, sự kiện & quy tắc comb/seq đúng",
              "moduledetail": [
                "Nội dung: Continuous vs procedural assignment; cơ chế tiến thời gian (#, @, wait); quy tắc viết comb procedural (đủ sensitivity list, gán đủ nhánh); vai trò initial vs always.",
                "Demo: Sửa always-comb thiếu sensitivity/gán thiếu nhánh để loại latch ẩn, thêm @(*).",
                "Source: verilog_comb_seq.v, testbench_tb.v.",
                "Document: Tutorial Behavioral Verilog Coding.",
                "Bài tập: Viết FA 1-bit dùng blocking; viết DFF dùng non-blocking; giải thích lý do."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 11: Tasks & Functions (P1): bản chất, khác biệt, cú pháp & ví dụ",
              "moduledetail": [
                "Nội dung: Tasks vs Functions (thời gian mô phỏng, số giá trị trả về, timing control, synthesize); cú pháp khai báo/gọi; function (logic tổ hợp, trả về 1 giá trị).",
                "Demo: Viết function [7:0] checksum8(data[63:0]); viết task drive_word phát stimulus.",
                "Source: tasks_functions.v, tb_tasks.v.",
                "Document: Tutorial Verilog Tasks & Functions.",
                "Bài tập: Refactor đoạn mã lặp thành 1 task + 1 function; giải thích lý do chọn."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 12: Tasks & Functions (P2): tái sử dụng trong testbench, phát vector & tự-kiểm",
              "moduledetail": [
                "Nội dung: Ghép task/function vào testbench; phát xung/clock, tạo/chấm test-vector, log; timescale, clock gen, $monitor/$display/$finish.",
                "Demo: Viết testbench tự-kiểm cho thanh ghi dịch + bộ đếm (emitBits, check).",
                "Source: tb_register_counter.v.",
                "Document: Tutorial Self-checking Testbench.",
                "Bài tập: Thiết kế tập ca kiểm thử bao phủ typical & corner cases cho DUT."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần G: Testbench & Verification",
          "module": [
            {
              "title": "Buổi 13: Testbench & Verification (P1): kiến trúc TB, PASS/FAIL, test-vectors",
              "moduledetail": [
                "Nội dung: Vai trò testbench, đọc test-vectors, áp vào DUT, log sai khác; cấu trúc testbench mẫu (tham số, instantiation, always/initial, task/function); PASS/FAIL compare đồng bộ.",
                "Demo: Xây TB cho DFF: clock gen, stimulus, comparator PASS/FAIL.",
                "Source: tb_dff.v.",
                "Document: Tutorial Testbench PASS/FAIL.",
                "Bài tập: Tạo TB tự-kiểm cho adder4 (structural) quét toàn bộ 16×16 đầu vào."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 14: Testbench & Verification (P2): timescale, specify & timing checks",
              "moduledetail": [
                "Nội dung: Timescale trong TB/DUT; khối specify ($setup, $hold, $width); minh họa TB DFF có fork/join tạo lệch pha để thấy PASS/FAIL + vi phạm timing.",
                "Demo: Thêm specify + $setup/$hold cho DFF; chạy ca vi phạm và ghi log.",
                "Source: tb_dff_timing.v.",
                "Document: Tutorial Timing Checks in Testbench.",
                "Bài tập: Giải thích khác nhau khi đổi timescale (độ phân giải, độ chính xác) trong TB/DUT."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần H: FSM coding & Mini-project",
          "module": [
            {
              "title": "Buổi 15: FSM coding & verification nâng cao: ma trận chuyển trạng thái, TB cho FSM",
              "moduledetail": [
                "Nội dung: Chuẩn bị state transition matrix trước khi tạo testbench; FSM Moore/Mealy bằng always @(posedge clk); phát ca kiểm thử bao phủ chuyển trạng thái (điển hình + biên), PASS/FAIL.",
                "Demo: Viết TB cho FSM 3-4 trạng thái (ví dụ detector dãy bit) theo ma trận chuyển trạng thái.",
                "Source: fsm_coding.v, tb_fsm.v.",
                "Document: Tutorial FSM Coding & Verification.",
                "Bài tập: Thêm ca cho trạng thái không tới được và reset bất chợt; báo cáo hành vi."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 16: Tích hợp mini-project: từ đặc tả → RTL → TB tự-kiểm → timing checks",
              "moduledetail": [
                "Nội dung: Vị trí pre-synthesis verification trong CAD flow; tổ chức design-test-testbench; checklist mini-project (test-vectors, PASS/FAIL tự động, báo cáo, timing ca).",
                "Demo: Mỗi nhóm demo TB tự-kiểm chạy trọn bộ ca, cung cấp log PASS/FAIL + minh chứng ca timing.",
                "Source: mini_project.v, tb_project.v, report_template.docx.",
                "Document: Guideline Final Project RTL & Testbench.",
                "Bài tập: Đóng gói repo mini-project (README, sơ đồ khối, bảng ca kiểm thử & bao phủ ca)."
              ],
              "image": "none"
            }
          ]
        }
      ]
    }
  },
  {
    "title": "Thiết kế SoC trên FPGA căn bản",
    "comment": "Thiết kế SoC theo hướng dùng lại Processor cứng có sẵn trên FPGA",
    "image": "none",
    "duration": "3 phần, 16 buổi",
    "detail": {
      "section": [
        {
          "title": "Phần A: Các thành phần SoC cơ bản",
          "module": [
            {
              "title": "Buổi 1: Giới thiệu SoC & Vi xử lý trên Xilinx/AMD FPGA",
              "moduledetail": [
                "Nội dung: Khái niệm SoC, kiến trúc PS-PL, vi xử lý ARM Cortex-A9/A53 trong Zynq",
                "Demo: Chơi game chạy trên Vi xử lý",
                "Source Code: Các code C/C++/Python/Javascript/… cơ bản chạy trên vi xử lý",
                "Document: Tài liệu tự biên soạn cho các loại vi xử lý trên FPGA",
                "Bài tập: Tìm hiểu kiến thức cơ bản về vi xử lý trên Xilinx/AMD FPGA"
              ],
              "image": "../images/slider/banner1.png"
            },
            {
              "title": "Buổi 2: Các ngoại vi trên PS và PL",
              "moduledetail": [
                "Nội dung: Ngoại vi PS và PL (UART, SPI, I2C, GPIO).",
                "Demo: Thực hành với các ngoại vi",
                "Source: Các code C điều khiện và Verilog cho ngoại vi",
                "Document: Tài liệu tự biên soạn cho các loại ngoại vi trên FPGA",
                "Bài tập: Viết các code Verilog cho ngoại vi chạy trên PS và PL"
              ],
              "image": "none"
            },
            {
              "title": "Buổi 3: Thiết kế AXI Bus",
              "moduledetail": [
                "Nội dung: Tổng quan AXI4, AXI-Full, AXI-lite, AXI-stream; master-slave transaction.",
                "Demo: Vivado block design với AXI Interconnect.",
                "Source: Các code Verilog mẫu cho các loại AXI4 bus.",
                "Document: Tài liệu tự biên soạn cho các loại AXI4 bus.",
                "Bài tập: Viết các code Verilog xử lý giao diện AXI-Full, AXI-lite, và AXI-stream bus."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 4: Thiết kế Memory subsystem",
              "moduledetail": [
                "Nội dung: DDR controller trong PS, BRAM, FIFO, LUTRAM trong PL, kết nối memory qua AXI.",
                "Demo: Đọc ghi dữ liệu từ memory ở DDR, BRAM, FIFO, LUTRAM.",
                "Source: Các code Verilog và code C điều khiển memory ở PS và PL.",
                "Document: Tài liệu tự biên soạn cho các loại memory trên PS và PL.",
                "Bài tập: Viết chương trình copy dữ liệu từ DDR sang BRAM."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 5: Thiết kế Custom IP cơ bản & tích hợp vào hệ thống SoC",
              "moduledetail": [
                "Nội dung: Viết Verilog cho multiplier_ip.v (thực hiện Y=A*X + B), đóng gói thành AXI4-Full, AXI4-Lite, và AXI-Stream IP.",
                "Demo: Block design (PS + multiplier IP).",
                "Source: Các code C điều khiển và Verilog cho ngoại vi.",
                "Document: Tài liệu tự biên soạn cho thiết kế custom IP cơ bản trên FPGA.",
                "Bài tập: Viết divider IP và đóng gói thành AXI4-Full, AXI4-Lite, và AXI-Stream IP."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 6: Tích hợp ILA để debug",
              "moduledetail": [
                "Nội dung: Giới thiệu Integrated Logic Analyzer (ILA), cách chèn ILA vào thiết kế để quan sát tín hiệu trong PL; so sánh debug bằng UART vs debug bằng ILA.",
                "Demo: Thêm ILA vào multiplier/divider IP, quan sát tín hiệu AXI handshake (AWVALID, AWREADY, WVALID, WREADY, RVALID, RREADY).",
                "Source: Code Verilog IP + file Vivado ILA configuration.",
                "Document: Tutorial tự biên soạn Debugging SoC Design with Vivado ILA (AISeQ Lab).",
                "Bài tập: Thêm ILA vào một module RAM hoặc counter, phân tích waveform của tín hiệu đọc/ghi."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần B: Linux setup",
          "module": [
            {
              "title": "Buổi 7: Cài đặt PetaLinux",
              "moduledetail": [
                "Nội dung: PetaLinux flow, kernel, rootfs, device tree.",
                "Demo: Build PetaLinux, boot Linux trên board.",
                "Source: Cấu hình PetaLinux cơ bản, script build.",
                "Document: Tutorial tự biên soạn cho cài đặt petalinux.",
                "Bài tập: Tự cài lại petalinux cho FPGA."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 8: Custom Device Tree và thêm Driver cho Kernel",
              "moduledetail": [
                "Nội dung: Cấu trúc Device Tree, binding custom IP; viết và thêm kernel driver cơ bản vào build PetaLinux.",
                "Demo: Thêm multiplier IP vào device tree, build kernel với driver mới.",
                "Source: File system-user.dtsi, multiplier_driver.c.",
                "Document: Tutorial tự biên soạn Custom Device Tree & Kernel Driver.",
                "Bài tập: Thêm node cho divider IP và build kernel với driver tương ứng."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần C: Project thực tế căn bản",
          "comment": "Ứng dụng 1: Digital Filter (FIR/IIR)",
          "module": [
            {
              "title": "Buổi 9: Thiết kế IP Digital Filter",
              "moduledetail": [
                "Nội dung: FIR filter (convolution), cấu trúc nhân-cộng.",
                "Demo: Tạo IP FIR với N tap = 8, test với data mẫu.",
                "Source: fir_ip.v, testbench FIR.",
                "Document: Tutorial tự biên soạn FIR Filter IP Design on FPGA.",
                "Bài tập: Mở rộng FIR N=16, so sánh resource FPGA."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 10: Hiện thực & đánh giá SoC tích hợp Digital Filter IP",
              "moduledetail": [
                "Nội dung: Tích hợp IP FIR vào SoC, điều khiển bằng PIO; lấy input từ ngoại vi (sensor giả lập hoặc file ADC), so sánh kết quả CPU vs FPGA.",
                "Demo: SoC chạy Linux, user app gửi data qua PIO, nhận kết quả filter.",
                "Source: fir_driver.c, app benchmark.",
                "Document: Tutorial tự biên soạn SoC with FIR Filter - PIO Control.",
                "Bài tập: Báo cáo latency & throughput cho 1000 mẫu tín hiệu."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 11: Thiết kế IP AES-128",
              "moduledetail": [
                "Nội dung: Cấu trúc AES-128 (ECB mode), tạo IP encrypt 128-bit block.",
                "Demo: IP AES-128 xử lý block dữ liệu test.",
                "Source: aes_ip.v, testbench AES.",
                "Document: Tutorial tự biên soạn AES-128 Hardware Design on FPGA.",
                "Bài tập: Thêm decrypt mode vào IP."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 12: Hiện thực & đánh giá SoC tích hợp AES-128 IP",
              "moduledetail": [
                "Nội dung: Tích hợp IP AES vào SoC, điều khiển bằng PIO; lấy input từ camera/video stream giả lập, mã hóa dữ liệu frame, benchmark CPU vs FPGA.",
                "Demo: SoC nhận frame ảnh/video, AES-128 encrypt, hiển thị kết quả mã hóa.",
                "Source: aes_driver.c, app benchmark.",
                "Document: Tutorial tự biên soạn SoC with AES-128 - Video Encryption via PIO.",
                "Bài tập: Báo cáo throughput (MB/s) khi mã hóa 1 video clip ngắn."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 13: Thiết kế IP nhân ma trận",
              "moduledetail": [
                "Nội dung: Nhân ma trận NxN, systolic array cơ bản.",
                "Demo: Tạo IP nhân ma trận 8x8, test dữ liệu bằng testbench.",
                "Source: matmul_ip.v, testbench matrix.",
                "Document: Tutorial tự biên soạn Matrix Multiplication IP Design.",
                "Bài tập: Thử mở rộng N=16."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 14: Hiện thực & đánh giá SoC tích hợp nhiều IP nhân ma trận",
              "moduledetail": [
                "Nội dung: Tích hợp nhiều IP vào SoC, điều khiển và truyền dữ liệu bằng PIO & DMA; so sánh CPU vs FPGA khi nhân ma trận.",
                "Demo: SoC thực hiện nhân ma trận với 4 IP nhân ma trận.",
                "Source: matmul_pio.c, benchmark script.",
                "Document: Tutorial tự biên soạn SoC with Multiple Matrix Multiplication IP.",
                "Bài tập: Báo cáo latency CPU vs FPGA cho N=8, 16."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 15 & 16: Báo cáo & Demo Final Project",
              "moduledetail": [
                "Nội dung: Sinh viên thuyết trình, demo project (FIR / AES / Matmul).",
                "Demo: FPGA chạy 1 trong 3 ứng dụng, benchmark trực tiếp.",
                "Source: Slide/report template.",
                "Bài tập: Nộp báo cáo + thuyết trình + kết quả benchmark CPU vs FPGA."
              ],
              "image": "none"
            }
          ]
        }
      ]
    }
  },
  {
    "title": "Thiết kế SoC nâng cao trên FPGA cho AI",
    "comment": "Tối ưu hóa IP tăng tốc Deep Learning với processor cứng SoC",
    "image": "none",
    "duration": "6 phần, 16 buổi",
    "detail": {
      "section": [
        {
          "title": "Phần A: Phát triển DNN Model",
          "module": [
            {
              "title": "Buổi 1: Giới thiệu về DNN & Training Model bằng TensorFlow",
              "moduledetail": [
                "Nội dung: Train LeNet-5 trên MNIST bằng TensorFlow, export weight FP32.",
                "Demo: Training + test accuracy ~98% trên PC.",
                "Source: Python/TensorFlow training script.",
                "Document: Tutorial Training LeNet-5 with TensorFlow.",
                "Bài tập: Train model và export weight/bias ra file .bin."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 2: Baseline Inference (FP32 vs Fixed-point)",
              "moduledetail": [
                "Nội dung: So sánh inference FP32 (baseline) vs Fixed-point (Q-format/INT8).",
                "Demo: Run inference LeNet-5 trên ARM CPU (FP32 vs INT8).",
                "Source: Python FP32 inference, C fixed-point inference.",
                "Document: Tutorial Floating vs Fixed-point Inference.",
                "Bài tập: Báo cáo latency & accuracy FP32 vs INT8."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần B: Xây dựng Accelerator Fixed-point",
          "module": [
            {
              "title": "Buổi 3: Thiết kế IP Convolution + Memory subsystem",
              "moduledetail": [
                "Nội dung: Conv2D accelerator fixed-point (systolic array, sliding window) + BRAM buffer + DDR interface.",
                "Demo: Conv IP 3x3 fixed-point với buffer BRAM, test ảnh MNIST.",
                "Source: conv_ip.v, buffer Verilog, testbench conv.",
                "Document: Tutorial Fixed-point Conv Accelerator with Memory Optimization.",
                "Bài tập: Mở rộng kernel 5x5, so sánh latency."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 4: Thiết kế IP Fully Connected + Memory subsystem",
              "moduledetail": [
                "Nội dung: Matrix-vector multiply accelerator (fixed-point) + DDR input/output + BRAM buffer.",
                "Demo: FC IP 128x128, test dữ liệu từ LeNet-5.",
                "Source: fc_ip.v, DDR/BRAM interface code.",
                "Document: Tutorial Fixed-point FC Accelerator with Memory Optimization.",
                "Bài tập: Benchmark latency cho 256x256."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 5: Tích hợp Accelerator vào SoC & Debug bằng ILA",
              "moduledetail": [
                "Nội dung: Tích hợp Conv/FC IP vào SoC qua AXI; chèn ILA để debug transaction (AWVALID, WVALID, RVALID…).",
                "Demo: Run inference test, capture waveform bằng Vivado ILA.",
                "Source: Block design Vivado, ILA config, testbench.",
                "Document: Tutorial Integrating Accelerator into SoC with ILA Debugging.",
                "Bài tập: Gắn ILA cho Conv IP, phân tích tín hiệu AXI handshake."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần C: Setup Linux & Driver",
          "module": [
            {
              "title": "Buổi 6: Build Linux & Custom Driver cho Accelerator",
              "moduledetail": [
                "Nội dung: Build PetaLinux, custom device tree, viết driver UIO/char cho Conv/FC IP.",
                "Demo: Boot Linux, test /dev/conv_accel.",
                "Source: conv_driver.c, system-user.dtsi.",
                "Document: Tutorial Linux Driver for AI Accelerators.",
                "Bài tập: Thêm node cho FC IP, xác minh bằng dmesg."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần D: Real-time inference & Đánh giá",
          "module": [
            {
              "title": "Buổi 7: Chạy real-time inference & Benchmark",
              "moduledetail": [
                "Nội dung: SoC inference dữ liệu real-time (camera/sensor stream), benchmark latency & throughput.",
                "Demo: Run LeNet-5 trên FPGA Accelerator, so sánh CPU vs FPGA.",
                "Source: cnn_realtime.c, benchmark script.",
                "Document: Tutorial Real-time Inference on FPGA SoC.",
                "Bài tập: Báo cáo latency & throughput cho stream 30 fps."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần E: Cải tiến Accelerator (Quantization & Pruning)",
          "module": [
            {
              "title": "Buổi 8: Quantization với TFLite",
              "moduledetail": [
                "Nội dung: FP32 → INT8 với TensorFlow Lite, phân tích trade-off accuracy.",
                "Demo: Convert LeNet-5 sang INT8.",
                "Source: TFLite quantization script.",
                "Document: Tutorial Quantization for FPGA Deployment.",
                "Bài tập: Báo cáo accuracy drop FP32 vs INT8."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 9: Benchmark Accelerator với Quantized Model",
              "moduledetail": [
                "Nội dung: Run quantized LeNet-5 trên FPGA, so sánh latency vs accuracy baseline.",
                "Demo: Inference INT8 trên FPGA Accelerator.",
                "Source: cnn_quant.c, benchmark log.",
                "Document: Tutorial Quantized CNN Accelerator.",
                "Bài tập: Báo cáo accuracy vs latency."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 10: Pruning Model bằng TensorFlow MOT",
              "moduledetail": [
                "Nội dung: Loại bỏ weights nhỏ, tạo sparse model.",
                "Demo: Prune LeNet-5 (50% sparsity).",
                "Source: TF pruning script.",
                "Document: Tutorial Model Pruning for Efficient FPGA Deployment.",
                "Bài tập: Báo cáo accuracy drop sau pruning."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 11: Benchmark Accelerator với Pruned Model",
              "moduledetail": [
                "Nội dung: Run pruned LeNet-5 trên FPGA.",
                "Demo: So sánh resource usage Dense vs Sparse.",
                "Source: cnn_prune.c, benchmark log.",
                "Document: Tutorial Pruned CNN Accelerator.",
                "Bài tập: Báo cáo latency, throughput, accuracy."
              ],
              "image": "none"
            }
          ]
        },
        {
          "title": "Phần F: Ứng dụng mở rộng & Final Project",
          "module": [
            {
              "title": "Buổi 12: Thiết kế & triển khai CNN cho CIFAR-10",
              "moduledetail": [
                "Nội dung: Mapping CNN nhỏ (3 conv + 2 FC) cho CIFAR-10 dataset.",
                "Demo: FPGA inference CIFAR-10.",
                "Source: cifar_cnn.v, dataset sample.",
                "Document: Tutorial Deploying CIFAR-10 CNN on FPGA.",
                "Bài tập: Benchmark latency batch 100 ảnh."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 13: Benchmark CNN cho CIFAR-10",
              "moduledetail": [
                "Nội dung: Đánh giá latency, throughput, accuracy cho CIFAR-10 trên FPGA.",
                "Demo: Benchmark SoC vs CPU.",
                "Source: cifar_bench.c, benchmark script.",
                "Document: Tutorial Benchmarking CIFAR-10 on FPGA.",
                "Bài tập: Báo cáo CPU vs FPGA cho CIFAR-10."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 14: Thiết kế & triển khai CNN cho Cat vs Dog dataset",
              "moduledetail": [
                "Nội dung: CNN nhỏ cho binary classification (Conv+FC).",
                "Demo: FPGA inference Cat vs Dog.",
                "Source: catdog_cnn.v, dataset sample.",
                "Document: Tutorial Deploying Cat vs Dog CNN on FPGA.",
                "Bài tập: Train Cat vs Dog CNN trên PC, export weights cho FPGA."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 15: Benchmark CNN cho Cat vs Dog",
              "moduledetail": [
                "Nội dung: Đánh giá latency, throughput, accuracy cho Cat vs Dog trên FPGA.",
                "Demo: Benchmark SoC vs CPU.",
                "Source: catdog_bench.c, benchmark script.",
                "Document: Tutorial Benchmarking Cat vs Dog CNN on FPGA.",
                "Bài tập: Báo cáo CPU vs FPGA cho Cat vs Dog dataset."
              ],
              "image": "none"
            },
            {
              "title": "Buổi 16: Báo cáo & Demo Final Project",
              "moduledetail": [
                "Nội dung: Sinh viên thuyết trình & demo project nhóm (LeNet-5, CIFAR-10 hoặc Cat vs Dog).",
                "Demo: FPGA chạy inference thực tế với model chọn.",
                "Source: Slide/report template.",
                "Document: Guideline Final Project Report & Demo.",
                "Bài tập: Nộp báo cáo + demo kết quả + benchmark CPU vs FPGA."
              ],
              "image": "none"
            }
          ]
        }
      ]
    }
  }
]
